use std::{net::SocketAddr, time::Duration};

use futures::{future, prelude::*};
use tarpc::{
    client,
    server::{self, incoming::Incoming, Channel},
    tokio_serde::formats::Json,
};
use tokio::{runtime::Runtime, time::sleep};

use super::*;
use crate::{
    conf::*,
    dprintln,
    drust_std::{alloc::INIT, connect::dsafepoint::set_ready, sync::dmutex::LOCAL_MUTEX_CACHE},
};

pub async fn start_alloc_server(server_addr: SocketAddr) -> anyhow::Result<()> {
    let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(100, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            let server = DAllocServer(channel.transport().peer_addr().unwrap());
            channel.execute(server.serve())
        })
        // Max 10 channels.
        .buffer_unordered(1000)
        .for_each(|_| async {})
        .await;
    anyhow::Ok(())
}

pub fn init_heap(server_addr: SocketAddr) {
    let heap_start = GLOBAL_HEAP_START + unsafe { SERVER_INDEX } * WORKER_UNIT_SIZE;
    let buffer_size = WORKER_UNIT_SIZE;
    dprintln!("heap_start: {:x}", heap_start);
    unsafe {
        LOCAL_ALLOCATOR.init(heap_start, buffer_size);
    }
    dprintln!("local allocator: {:x}", unsafe {
        &LOCAL_ALLOCATOR as *const _ as usize
    });
    Runtime::new()
        .unwrap()
        .block_on(start_alloc_server(server_addr))
        .unwrap();
}

pub async fn init_connections(alloc_server_addrs: [SocketAddr; NUM_SERVERS]) {
    dprintln!("init connections");
    let alloc_server_index = unsafe { SERVER_INDEX };
    let mut clients = Vec::new();
    for i in 0..NUM_SERVERS {
        dprintln!("Connecting to server {}", i);
        let mut transport =
            tarpc::serde_transport::tcp::connect(&alloc_server_addrs[i], Json::default);
        transport.config_mut().max_frame_length(usize::MAX);
        // let fut_transport = Runtime::new().unwrap().block_on(transport).expect("failed to connect");
        let fut_transport = transport.await.expect("failed to connect");
        let client =
            Arc::new(DAllocatorClient::new(client::Config::default(), fut_transport).spawn());
        clients.push(client);
    }

    let mut remote_allocators = Vec::new();
    for i in 0..NUM_SERVERS {
        let aref = if i == alloc_server_index {
            unsafe { &LOCAL_ALLOCATOR as *const _ as usize }
        } else {
            let client_ref = Arc::clone(&clients[i]);
            std::thread::spawn(move || {
                Runtime::new()
                    .unwrap()
                    .block_on(client_ref.get_allocator(context::current()))
            })
            .join()
            .unwrap()
            .unwrap()
        };
        remote_allocators.push(aref);
    }

    unsafe {
        INIT.call_once(|| {
            DALLOCTOR = Some(clients);
            REMOTE_ALLOCATORS = Some(remote_allocators);
            REF_MAP = Some(Arc::new(DashMap::new()));
            LOCAL_MUTEX_CACHE = Some(DashMap::new());
        });
    }

    // Testing the allocator at initilization
    let client = Arc::clone(&unsafe { DALLOCTOR.as_ref().unwrap() }[0]);
    let (addr, allocated_size) = client.rallocate(context::current(), 32, 8).await.unwrap();
    dprintln!("addr: {}, allocated_size: {}", addr, allocated_size);
    let client = Arc::clone(&unsafe { DALLOCTOR.as_ref().unwrap() }[0]);
    client
        .rdeallocate(context::current(), addr, 32, 8)
        .await
        .unwrap();
    dprintln!(
        "deallocate addr: {}, allocated_size: {}",
        addr,
        allocated_size
    );

    set_ready(1);

    loop {
        sleep(Duration::from_secs(1)).await;
    }
}
