use crate::conf::*;
use dashmap::DashMap;
use futures::{future, prelude::*};
use std::sync::{Arc, Once};
use std::{
    alloc::{Allocator, Layout},
    net::SocketAddr,
    ops::{Add, Rem},
    ptr::NonNull,
    time::{Duration, SystemTime},
};
// use rand::distributions::Distribution;
use crate::dprintln;
use tarpc::{
    client, context,
    server::{self, incoming::Incoming, Channel},
    tokio_serde::formats::Json,
};
use tokio::{runtime::Runtime, time::sleep};

#[tarpc::service]
pub trait DSafePoint {
    /// Returns a greeting for name.
    async fn is_ready(idx: usize) -> bool;
    async fn wait_ready(idx: usize);
    async fn unset_ready(idx: usize);
    async fn reset();
    async fn shutdown();
}

#[derive(Clone)]
struct DSafePointServer(SocketAddr);

pub static mut READY_MAP: Option<Arc<DashMap<usize, bool>>> = None;
pub static SHUTDOWN_INDEX: usize = 20240327;

#[tarpc::server]
impl DSafePoint for DSafePointServer {
    async fn is_ready(self, _: context::Context, idx: usize) -> bool {
        unsafe {
            if let Some(map) = &READY_MAP {
                if let Some(ready) = map.get(&idx) {
                    return *ready;
                }
            }
        }
        false
    }
    async fn wait_ready(self, _: context::Context, idx: usize) {
        unsafe {
            if let Some(map) = &READY_MAP {
                while !map.contains_key(&idx) {
                    sleep(Duration::from_millis(100)).await;
                }
            }
        }
    }
    async fn unset_ready(self, _: context::Context, idx: usize) {
        unsafe {
            if let Some(map) = &READY_MAP {
                map.remove(&idx);
            }
        }
    }
    async fn reset(self, _: context::Context) {
        unsafe {
            if let Some(map) = &READY_MAP {
                map.clear();
            }
        }
    }
    async fn shutdown(self, _: context::Context) {
        unsafe {
            if let Some(map) = &READY_MAP {
                map.insert(SHUTDOWN_INDEX, true);
            }
        }
    }
}

pub async fn start_safepoint_server(server_addr: SocketAddr) -> anyhow::Result<()> {
    unsafe {
        READY_MAP = Some(Arc::new(DashMap::new()));
    }

    let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(100, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            let server = DSafePointServer(channel.transport().peer_addr().unwrap());
            channel.execute(server.serve())
        })
        // Max 10 channels.
        .buffer_unordered(1000)
        .for_each(|_| async {})
        .await;
    anyhow::Ok(())
}

pub async fn rsync(sync_server_addrs: &[SocketAddr; NUM_SERVERS], target_idx: usize) {
    let mut sync_clients = Vec::new();
    for i in 0..NUM_SERVERS {
        let mut transport =
            tarpc::serde_transport::tcp::connect(&sync_server_addrs[i], Json::default);
        transport.config_mut().max_frame_length(usize::MAX);
        let fut_transport = transport.await.expect("failed to connect");
        let client =
            Arc::new(DSafePointClient::new(client::Config::default(), fut_transport).spawn());
        sync_clients.push(client);
    }
    for i in 0..NUM_SERVERS {
        let mut ctx = context::current();
        ctx.deadline = SystemTime::now() + Duration::from_secs(RPC_WAIT);
        sync_clients[i]
            .wait_ready(ctx, target_idx)
            .await
            .expect("failed to wait ready");
    }
    sleep(Duration::from_secs(1)).await;
    dprintln!("rsync done for {}", target_idx);
}

pub fn set_ready(idx: usize) {
    unsafe {
        if let Some(map) = &READY_MAP {
            map.insert(idx, true);
        }
    }
}

pub async fn rshutdown(sync_server_addrs: &[SocketAddr; NUM_SERVERS]) {
    let mut sync_clients = Vec::new();
    for i in 0..NUM_SERVERS {
        let mut transport =
            tarpc::serde_transport::tcp::connect(&sync_server_addrs[i], Json::default);
        transport.config_mut().max_frame_length(usize::MAX);
        let fut_transport = transport.await.expect("failed to connect");
        let client =
            Arc::new(DSafePointClient::new(client::Config::default(), fut_transport).spawn());
        sync_clients.push(client);
    }
    for i in 0..NUM_SERVERS {
        if i == unsafe { SERVER_INDEX } {
            continue;
        }
        println!("shutting down {}", i);
        sync_clients[i]
            .shutdown(context::current())
            .await
            .expect("failed to shutdown");
    }
}
